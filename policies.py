import chess
from abc import ABC
from hash import zobrist_hash
from typing import Callable, TypeAlias
import numpy as np

CHECKMATE_SCORE = 1000000
HASH_LENGTH = 20
TTABLE_SIZE = 2**HASH_LENGTH
TT_ENABLED = True

ttable_entry_type = np.dtype([
            ("hash", np.uint64),
            ("depth", np.int32),
            ("eval", np.int32),
            ("move", "S5"),
        ])


def random_move(board: chess.Board) -> chess.Move:
    import random
    legal_moves = list(board.legal_moves)
    return random.choice(legal_moves)


def get_material(board: chess.Board, color) -> int:
    piece_values = {
        chess.PAWN: 1,
        chess.KNIGHT: 3,
        chess.BISHOP: 3,
        chess.ROOK: 5,
        chess.QUEEN: 9,
        chess.KING: 0
    }
    total_value = 0

    for piece_type in piece_values:
        piece_count = len(board.pieces(piece_type, color))
        total_value += piece_count * piece_values[piece_type]

    return total_value


def get_current_player_material(board: chess.Board) -> int:
    return get_material(board, board.turn)


def get_material_difference(board: chess.Board) -> int:
    white_material = get_material(board, chess.WHITE)
    black_material = get_material(board, chess.BLACK)
    return white_material - black_material


def minimax(board_: chess.Board, eval: Callable[[chess.Board], int], depth: int = 7, ttable: np.ndarray = np.empty(TTABLE_SIZE, dtype=ttable_entry_type)) -> chess.Move:
    board = board_.copy()
    nodes_visited: int = 0

    def minimax_inner(depth, alpha: int = -CHECKMATE_SCORE, beta: int = CHECKMATE_SCORE) -> tuple[int, chess.Move]:
        nonlocal nodes_visited
        nodes_visited += 1
        hash = zobrist_hash(board, HASH_LENGTH)
        tt_entry = ttable[hash]
        if tt_entry["hash"] == hash:
            move = chess.Move.from_uci(tt_entry["move"].decode("utf-8"))
            return tt_entry["eval"], move

        if board.is_checkmate():
            if board.turn == chess.WHITE:
                return -CHECKMATE_SCORE, board.peek()
            else:
                return CHECKMATE_SCORE, board.peek()
        
        if board.is_stalemate() or board.is_insufficient_material():
            return 0, board.peek()

        if depth == 0:
            return eval(board), board.peek()
        
        possible_moves: list[tuple[int, chess.Move]] = []
        
        for move in board.legal_moves:
            
            board.push(move)
            score = minimax_inner(depth - 1, alpha, beta)[0]
            board.pop()

            if board.turn == chess.WHITE:
                if score > alpha:
                    alpha = score
                elif score >= beta:
                    return score, move
            else:
                if score < beta:
                    beta = score
                elif score <= alpha:
                    return score, move

            possible_moves.append((score, move))
        
        if board.turn == chess.WHITE:
            score, move = max(possible_moves, key=lambda x: x[0])
        else:
            score, move = min(possible_moves, key=lambda x: x[0])
        
        if TT_ENABLED:
            tt_entry["hash"] = hash
            tt_entry["depth"] = depth
            tt_entry["eval"] = score
            tt_entry["move"] = move.uci()

        return score, move

    move = minimax_inner(depth)[1]
    print(f"Nodes visited: {nodes_visited}")
    return move
    


def greedy_search(board: chess.Board, depth: int = 5):
    return minimax(board, get_material_difference, depth)


class Bot(ABC):
    def __init__(self, policy: Callable[[chess.Board], chess.Move], depth: int = 5):
        """
        Initialize the Bot with a color and a policy function.
        :param policy: A callable function that takes a chess board and returns a move in UCI.
        """
        if policy is None:
            raise ValueError("Policy function must be provided.")
        self.policy = policy
        self.depth = depth

    def make_move(self, board: chess.Board):
        # Simple AI: Random move
        move = self.policy(board)
        if move not in board.legal_moves:
            raise Exception(f"Illegal move generated by policy. Move: {move}")
        board.push(move)
        print(f"Bot played: {move}")


class MinimaxBot(Bot, ABC):
    def __init__(self, eval: Callable[[chess.Board], int], depth: int = 5):
        policy = lambda board: minimax(board, eval, depth)
        super().__init__(policy, depth)
        self.depth = depth
        self.ttable = np.empty(TTABLE_SIZE, dtype=ttable_entry_type)
        self.evaluate_board = eval
        policy = lambda board: minimax(board, eval, self.depth, self.ttable)


class Player(Bot):
    def __init__(self, color):
        self.color = color

    def make_move(self, board):
        move = input(f"Player {self.color}, enter your move: ")
        try:
            board.push_uci(move)
        except ValueError:
            print("Invalid move. Try again.")
            self.make_move(board)


class GreedyBot(MinimaxBot):
    def __init__(self, depth = 5):
        super().__init__(get_material_difference, depth)


greedy_bot = GreedyBot(depth=5)