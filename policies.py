import chess
from abc import ABC
from hash import zobrist_hash
from typing import Callable

CHECKMATE_SCORE = 1000000


def random_move(board: chess.Board) -> chess.Move:
    import random
    legal_moves = list(board.legal_moves)
    return random.choice(legal_moves)


def get_material(board: chess.Board, color) -> int:
    piece_values = {
        chess.PAWN: 1,
        chess.KNIGHT: 3,
        chess.BISHOP: 3,
        chess.ROOK: 5,
        chess.QUEEN: 9,
        chess.KING: 0
    }
    total_value = 0

    for piece_type in piece_values:
        piece_count = len(board.pieces(piece_type, color))
        total_value += piece_count * piece_values[piece_type]

    return total_value


def get_current_player_material(board: chess.Board) -> int:
    return get_material(board, board.turn)


def get_material_difference(board: chess.Board) -> int:
    white_material = get_material(board, chess.WHITE)
    black_material = get_material(board, chess.BLACK)
    return white_material - black_material


# def heuristic(board: chess.Board, move: chess.Move) -> float:
#     pass

# def ids(board: chess.Board, heuristic: callable, depth: int = 7) 

def minimax(board_: chess.Board, eval: Callable[[chess.Board], float], depth: int = 7):
    board = board_.copy()

    def minimax_inner(depth, alpha: int = -CHECKMATE_SCORE, beta: int = CHECKMATE_SCORE):
        if board.is_checkmate():
            if board.turn == chess.WHITE:
                return -CHECKMATE_SCORE, board.peek()
            else:
                return CHECKMATE_SCORE, board.peek()
        
        if board.is_stalemate() or board.is_insufficient_material():
            return 0, board.peek()

        if depth == 0:
            return eval(board), board.peek()
        
        possible_moves = []
        
        for move in board.legal_moves:
            
            board.push(move)
            score = minimax_inner(depth - 1, alpha, beta)[0]
            board.pop()

            if board.turn == chess.WHITE:
                if score > alpha:
                    alpha = score
                elif score >= beta:
                    return score, move
            else:
                if score < beta:
                    beta = score
                elif score <= alpha:
                    return score, move

            possible_moves.append((score, move))
        
        if board.turn:
            return max(possible_moves, key=lambda x: x[0])
        else:
            return min(possible_moves, key=lambda x: x[0])
    
    return minimax_inner(depth)[1]
    


def greedy_search(board: chess.Board, depth: int = 5):
    return minimax(board, get_material_difference, depth)


class Bot(ABC):
    def __init__(self, policy: Callable[[chess.Board], chess.Move], depth: int = 5):
        """
        Initialize the Bot with a color and a policy function.
        :param policy: A callable function that takes a chess board and returns a move in UCI.
        """
        if policy is None:
            raise ValueError("Policy function must be provided.")
        self.policy = policy
        self.depth = depth

    def make_move(self, board: chess.Board):
        # Simple AI: Random move
        move = self.policy(board)
        if move not in board.legal_moves:
            raise Exception(f"Illegal move generated by policy. Move: {move}")
        board.push(move)
        print(f"Bot played: {move}")


class MinimaxBot(Bot, ABC):
    def __init__(self, eval: Callable[[chess.Board], int], depth: int = 5):
        policy = lambda board: minimax(board, eval, depth)
        super().__init__(policy, depth)
        self.depth = depth
        policy = lambda board: minimax(board, eval, self.depth)
        self.evaluate_board = eval


class Player(Bot):
    def __init__(self, color):
        self.color = color

    def make_move(self, board):
        move = input(f"Player {self.color}, enter your move: ")
        try:
            board.push_uci(move)
        except ValueError:
            print("Invalid move. Try again.")
            self.make_move(board)


class GreedyBot(MinimaxBot):
    def __init__(self, depth = 5):
        super().__init__(get_material_difference, depth)


greedy_bot = GreedyBot(depth=5)